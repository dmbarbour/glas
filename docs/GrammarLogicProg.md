# Programming with Grammars and Logic

## Overview

A grammar represents a set of values in a manner that enables efficient recognition and generation of those values. In context of glas systems, we'll support grammars over binary trees. But I use text in examples, for convenience. Text is encoded into a subset of binary trees. 

It is possible to record useful information into a grammar. For example, if our values are `{"roses are red", "violets are blue"}`, we have represented information about colors of things. It is possible to query a grammar based on a partial match and binding variables. Matching `"${things} are red"` effectively defines 'things' to be "roses". Matching multiple variables produces sets of consistent definitions, e.g. to match `"${things} are ${color}"` effectively generates `{(things="roses", color="red"), (things="violets", color="blue")}`.

Logic programming is ultimately based on shared variables. The same value must be computed at every location the variable is used, via combined recognition and generation. This constrains potential values for the variable. To fully leverage this, we extend grammars with guards, i.e. in `Pattern when Guard`, the Guard must generate a value but is detached from the final output. Logic programming's reverse implication clauses (`Proposition :- Derivation`) can be understood as a syntactic sugar for guarded patterns.

Parsing or pattern matching with grammars are conveniently expressed in terms of production rules of form `Text => AST` or generally `Pattern => Production`. Variables in production rules implicitly refer to the production, e.g. in `"while" (Cond as C) "do" ... => loop:(cond:C, ...)`, variable 'C' should refer to the AST generated by parsing Cond text. Of course, the language can also provide convenient access to raw text with careful design of syntax. 

Production rules can be locally understood as syntactic sugar over relations, using guard patterns and variables to break up the pairs. Relatedly, a language might desugar 'function call' expressions to work with relations in expression of the Production. Between these, grammar-logic languages might conveniently support a functional programming style, albeit with ambiguity when there are multiple valid productions.

Interactive computation is implicit insofar as two or more grammars constrain each other to generate a value. This can be leveraged explicitly. For example, we could model a procedural trace (abstracting the procedure's logic) as `(args:Arguments, eff:[(Request1, Response1), (Request2, Response2), ...], return:Result)`. A 'procedure' would then be represented by a grammar that reads Arguments, writes Requests, reads Responses, and writes a Result. Other grammars might represent caller and effect handler, writing the Arguments and Responses. 

A runtime could bind interactions to the real world, albeit under a constraint that requests can safely be backtracked. The [transaction machine application model](GlasApps.md) is a good fit. Also, sequential request-response interactions aren't the limit. We could just as easily 'trace' a dynamic process network communicating via channels. Also, where necessary, [session types](https://en.wikipedia.org/wiki/Session_type) can help programmers precisely control dataflow.

Production rules in a grammar-logic language could desugar into 'interactions' instead of 'relations'. This would simplify extension of 'functions' with effects or concurrent decomposition.

Grammar-logic languages have potential to be very modular and extensible. Relevantly, a language AST is typically expressed using named rules for parsing Statements, Loops, Integers, and other AST components. Named rules are convenient for expressing mutual recursion (a Statement contains a Loop which contains a Statement), and are also convenient targets for extension, e.g. we could extend a grammar with a new Loop structure without rewriting the entire grammar. This idea is closely related to multiple inheritance and mixins in OOP.

*Note:* One use-case for grammar-logic is developing glas language modules, e.g. define global module `language-json` to compile ".json" files into glas values. In this context, we might raise an 'ambiguity error' if compilation does not produce a single, deterministic value.

## Desiderata

Specific features I want for glas systems.

* Structural termination guarantee for most computations. 
* Support for annotation and acceleration of grammars.
* Flexible extension and composition of grammars.
* Expressive and scalable standard interaction model.

One feature I don't care about is 'dynamic' grammars. Any extension and composition may be static in nature, independent of production arguments. To simplify metaprogramming, I might introduce an extra stage after construction of the value that represents the composed grammar but before we actually parse or produce anything.

