# LIST OPERATIONS
#
# Lists in Glas are logically constructed of pairs, terminating in unit. This
# is essentially a Lisp-like construction of lists, using cons cells and null
# terminator. 
#
#       type List a = (a * List a) | ()
# 
# However, Glas systems are assumed to accelerate lists. Under-the-hood, lists 
# will be represented by a rope-like finger-tree structure by default. This can
# support double-ended queue access, log-time split and join, compact binaries,
# and structure sharing of fragments within a list.
#
# A finger-tree rope is a good one-size-fits-most representation of lists. It is
# feasible for a compiler or runtime to specialize list representations for other
# use cases, e.g. use a mutable array in a context where it isn't copied.
#

open prims

# list          Value -- ListValue | FAIL
#  Check if input is a list. Fails if input value is not a list, otherwise
#  returns the input value but with accelerated representation.
prog list-impl [[[unpair [drop] dip] loop 0 eq] verify]
prog list [[list-impl] 'list p-anno-accel apply]

assert [ 2 1 0 pair pair copy list eq ]
assert [ 3 2 1 pair pair [list] reject drop ]

# pushl (V L -- V:L)
#  same as pair except fails if L is a non-list value.
prog pushl [pair list]

# popl (V:L -- V L)
#  same as unpair except fails for a non-list value.
prog popl [unpair list]

# list-each ([Op] => (ABC -- A Op B Op C Op))
prog p-list-each [[popl] swap p-dip p-while-do [0 eq] p-seq]
macro each [p-list-each]

# list-reverse-append (CBA DEF -- ABCDEF)
prog list-reverse-append [swap [swap pushl] list-each]

# list-reverse  (ABCDEF -- FEDCBA)
#  list reverse is not accelerated.
prog list-reverse [0 list-reverse-append]
assert ["hello" list-reverse "olleh" eq]

# append (ABC DEF -- ABCDEF)
#  Concatenate two lists. 
prog list-append-impl [[list-reverse] dip list-reverse-append]
assert ["abc" "def" list-append-impl "abcdef" eq]
prog list-append [[list-append-impl] 'list-append p-anno-accel apply]

data l0 [0]
prog l1 [l0 pushl]
prog l2 [l1 pushl]
prog l3 [l2 pushl]
prog l4 [l3 pushl]
prog l5 [l4 pushl]
prog l6 [l5 pushl]
prog l7 [l6 pushl]
assert [0x6f 0x6d 0x6e 0x2d 0x6e 0x6f 0x6d l7 "omn-nom" eq]

# maybe add expansions for lists of sizes 0..7.
prog unl0 [0 eq]
prog unl1 [popl unl0]
prog unl2 [popl unl1]
prog unl3 [popl unl2]
prog unl4 [popl unl3]
prog unl5 [popl unl4]
prog unl6 [popl unl5]
prog unl7 [popl unl6]
assert ["omn-nom" unl7 0x6d eq 0x6f eq 0x6e eq 0x2d eq 0x6e eq 0x6d eq 0x6f eq]

# pushr (L V -- L:V)
prog pushr [l1 list-append]
assert ["pin" 0x67 pushr "ping" eq]


# popr (L:V -- L V)
prog popr-impl [rev popl rev swap]
assert ["pint" popr-impl 0x74 eq "pin" eq]
prog popr [[popr-impl] 'list-popr p-anno-accel apply]

# li
#  For pseudo-literal construction of lists.
#
#   l0 "this was a triumph"
#   li "making a note here,"
#   li "  huge success!"
#   li " -- GlaDOS" 
#   li unlines
#
prog li [pushr]

