open prims

# LIST OPERATIONS
#
# Lists in Glas are logically constructed of pairs, terminating in a single-node
# tree (aka unit, represented in g0 by value 0).  
#
# However, Glas systems are *expected* to accelerate the representation of lists,
# hopefully using finger-trees, rope structures, and stowage to work efficiently
# with very large lists. This supports high-performance access to both ends, join,
# and slicing. 

# list      Value -- List | FAIL
#  Fails if input is not a valid list. Otherwise returns input. In context
#  of acceleration, the returned list may have the optimized representation.
prog list-impl [[[unpair [drop] dip] loop 0 eq] verify]
prog list [[list-impl] 'type p-anno-accel apply]

assert [ 2 1 0 pair pair copy list eq]
assert [ 3 2 1 pair pair copy [list] verify-not eq ]

# pushl (V L -- V:L)
#  same as pair except fails if L is a non-list value.
prog pushl [[list pair] 'list p-anno-accel apply]

# popl (V:L -- V L)
#  same as unpair except fails for a non-list value.
prog popl [[list unpair] 'popl p-anno-accel apply]

# each ([Op] => (ABC -- A Op B Op C Op))
prog p-each [[popl] swap p-dip p-while-do [0 eq] p-seq]
macro each [p-each]

# rev-app (CBA DEF -- ABCDEF)
prog rev-app [swap [swap pushl] each]

# rev  (ABCDEF -- FEDCBA)
#  list reverse is not accelerated.
prog rev [0 rev-app]
assert ["hello" rev "olleh" eq]

# append (ABC DEF -- ABCDEF)
prog append-impl [[rev] dip rev-app]
assert ["abc" "def" append-impl "abcdef" eq]
prog append [[append-impl] 'append p-anno-accel apply]

data l0 [0]
prog l1 [l0 pushl]
prog l2 [l1 pushl]
prog l3 [l2 pushl]
prog l4 [l3 pushl]
prog l5 [l4 pushl]
prog l6 [l5 pushl]
prog l7 [l6 pushl]
assert [0x6f 0x6d 0x6e 0x2d 0x6e 0x6f 0x6d l7 "omn-nom" eq]

# maybe add expansions for lists of sizes 0..7.
prog unl0 [0 eq]
prog unl1 [popl unl0]
prog unl2 [popl unl1]
prog unl3 [popl unl2]
prog unl4 [popl unl3]
prog unl5 [popl unl4]
prog unl6 [popl unl5]
prog unl7 [popl unl6]
assert ["omn-nom" unl7 0x6d eq 0x6f eq 0x6e eq 0x2d eq 0x6e eq 0x6d eq 0x6f eq]

# pushr (L V -- L:V)
prog pushr-impl [swap rev pushl rev]
assert ["pin" 0x67 pushr-impl "ping" eq]
prog pushr [[pushr-impl] 'list-pushr p-anno-accel apply]

# popr (L:V -- L V)
prog popr-impl [rev popl rev swap]
assert ["pint" popr-impl 0x74 eq "pin" eq]
prog popr [[popr-impl] 'list-popr p-anno-accel apply]

# li
#  For pseudo-literal construction of lists.
#
#   l0 "this was a triumph"
#   li "making a note here,"
#   li "  huge success!"
#   li " -- GlaDOS" 
#   li unlines
#
prog li [pushr]

