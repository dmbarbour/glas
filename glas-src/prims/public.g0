# The 'prims' module provides a useful set of words for getting started with
# the g0 language. This includes defining all the basic Glas program primitives
# but also a few convenient utility functions.
#
# At the moment, list ops, natural number arithmetic, and advanced record ops
# such as iteration over keys is left to external modules. I might create a
# different module that includes an entire standard library.

macro apply []

# TRUE PRIMITIVES

prog copy ['copy apply]
prog swap ['swap apply]
prog drop ['drop apply]

prog eq ['eq apply]
prog eff ['eff apply]
prog fail ['fail apply]

prog get ['get apply]
prog put ['put apply]
prog del ['del apply]

# default halt with empty message.
prog halt ['halt apply]

prog p-dip [0 'dip put]
prog p-while-do [0 'do put 'while put 0 'loop put]
prog p-until-do [0 'do put 'until put 0 'loop put]
prog p-try-then-else [0 'else put 'then put 'try put 0 'cond put]
prog p-with-do [0 'do put 'with put 0 'env put]
prog p-halt-with-msg [0 'halt put]

macro dip [p-dip]
macro while-do [p-while-do]
macro until-do [p-until-do]
macro try-then-else [p-try-then-else]
macro with-do [p-with-do]
macro halt-with-msg [p-halt-with-msg]

# halt with certain errors
prog tbd ['tbd halt-with-msg]
prog type-error ['type-error halt-with-msg]
prog unreachable ['unreachable halt-with-msg]

# PAIRS - trees with both the '0' and '1' edges.
# Pairs are mostly used for construction of lists.

prog pair [0 0b1 put 0b0 put]
prog pair-fst [0b0 get]
prog pair-snd [0b1 get]
prog unpair [copy pair-fst swap pair-snd]
assert [1 2 3 pair pair pair-snd unpair 3 eq 2 eq]

# DATA AND SEQ MACRO SUPPORT
#
# No need for 'data' or 'seq' as macros, but p-* forms
# are very convenient for construction of new macros.

# p-data    Value -- [Value]
prog p-data [0 'data put]

# p-seq     ([A] [B] -- [A B])
#  compose two programs sequentially.
prog p-seq  [['seq get] [pair] [0 pair pair] try-then-else 0 'seq put]

# p-curry   (Value [Fn] -- [Value Fn])
#  bind first parameter into a program value.
prog p-curry [[p-data] dip p-seq]

# p-nop     -- []
#  non-operation in Glas is empty seq
data p-nop ['seq]

assert [1 [2 pair] p-curry apply unpair 2 eq 1 eq]

# CONDITIONAL VARIATIONS

# try       ([P]try == [P][][]try-then-else)
# try-then  ([P][L]try-then == [P][L][]try-then-else)
# try-else  ([P][R]try-else == [P][][R]try-then-else)
prog p-try [0 'try put 0 'cond put]
prog p-try-then [0 'then put 'try put 0 'cond put]
prog p-try-else [0 'else put 'try put 0 'cond put]
macro try [p-try]
macro try-then [p-try-then]
macro try-else [p-try-else]

# NON-MODIFYING OBSERVATIONS
#
# Many uses of these operations might be better expressed as typechecks,
# or otherwise as annotations. However, they do have some use-cases.

# verify    ([Predicate] -- | FAIL)
#  evaluates predicate, then undoes effects.
#  passes if the predicate would pass, fails otherwise.
prog p-verify [[fail] p-try-then [fail] p-try-then]
macro verify [p-verify]
assert [0 [0 eq] verify 0 eq]
assert [0 [[1 eq] verify][1][2] try-then-else 2 eq 0 eq]

# verify-not ([Predicate] -- | FAIL)
#  evaluates predicate, then undoes effects.
#  passes if predicate would fail, succeeds otherwise.
prog p-verify-not [[fail] p-try-then [fail] p-try-else]
macro verify-not [p-verify-not]
assert [0 [1 eq] verify-not 0 eq]
assert [0 [[0 eq] verify-not][1][2] try-then-else 2 eq 0 eq]

# reject - same as 'verify-not'
macro reject [p-verify-not]

# LOOP VARIATIONS

# loop          ([Op]loop)
#  run sub-program repeatedly until it fails.
prog p-loop [0 'while put 0 'loop put]
macro loop [p-loop]

# do-while      ([Body][Cond]do-while)
#  run Body before checking condition. Equivalent: 
#    Body [Cond] [Body] while-do
prog p-do-while [[copy] dip swap p-while-do p-seq]
macro do-while [p-do-while]

# do-until      ([Body][Cond]do-until)
#  run Body before checking condition. Equivalent:
#    Body [Cond] [Body] until-do
prog p-do-until [[copy] dip swap p-until-do p-seq]
macro do-until [p-do-until]

# DATA PLUMBING SUPPORT
# 
# rot3      (X Y Z -- Y Z X)        rotate 3rd item to top
# unrot3    (X Y Z -- Z X Y)               top item to 3rd
# copy2     (X Y -- X Y X Y)        copy two items on stack
# drop2     (X Y -- )               drop two items from stack
# dip2      (X Y [Op] -- Op X Y)    hide two items from Op
#
# All of these have variants from 2..7. However, a data stack over a few
# elements grows difficult to mentally track or manage, so you should be
# organizing data (into records, lists, etc.) to keep the stack small.

prog rot2 [swap]
prog rot3 [[rot2] dip swap]
prog rot4 [[rot3] dip swap]
prog rot5 [[rot4] dip swap]
prog rot6 [[rot5] dip swap]
prog rot7 [[rot6] dip swap]

assert [1 2 3 4 5 6 7 rot7 1 eq 7 eq 6 eq 5 eq 4 eq 3 eq 2 eq]

prog unrot2 [swap]
prog unrot3 [swap [unrot2] dip]
prog unrot4 [swap [unrot3] dip]
prog unrot5 [swap [unrot4] dip]
prog unrot6 [swap [unrot5] dip]
prog unrot7 [swap [unrot6] dip]

assert [1 2 3 4 5 6 7 unrot7 6 eq 5 eq 4 eq 3 eq 2 eq 1 eq 7 eq]

prog copy2 [[copy ] dip copy [unrot2] dip]
prog copy3 [[copy2] dip copy [unrot3] dip]
prog copy4 [[copy3] dip copy [unrot4] dip]
prog copy5 [[copy4] dip copy [unrot5] dip]
prog copy6 [[copy5] dip copy [unrot6] dip]
prog copy7 [[copy6] dip copy [unrot7] dip]

assert [1 2 3 4 5 6 7 copy7 [7 eq 6 eq 5 eq 4 eq 3 eq 2 eq] copy dip dip 1 eq 1 eq]

prog drop2 [drop drop]
prog drop3 [drop drop drop]
prog drop4 [drop drop drop drop]
prog drop5 [drop drop drop drop drop]
prog drop6 [drop drop drop drop drop drop]
prog drop7 [drop drop drop drop drop drop drop]

assert [1 2 3 4 5 6 7 8 drop7 1 eq]

macro dip2 [p-dip p-dip]
macro dip3 [p-dip p-dip p-dip]
macro dip4 [p-dip p-dip p-dip p-dip]
macro dip5 [p-dip p-dip p-dip p-dip p-dip]
macro dip6 [p-dip p-dip p-dip p-dip p-dip p-dip]
macro dip7 [p-dip p-dip p-dip p-dip p-dip p-dip p-dip]

assert [1 2 3 4 5 6 7 8 9 [2 eq] dip7 9 eq 8 eq 7 eq 6 eq 5 eq 4 eq 3 eq 1 eq]

# CONVENIENCE FUNCTIONS FOR RECORDS AND VARIANTS

# getd          Record Label Default -- Value
#  get with a default value.
prog getd [[drop get] [[drop2] dip] try-else]

assert [42 0 'x put copy 'x 0 getd 42 eq 'y 0 getd 0 eq]

# putd          Value Record Label Default -- Record
#  put with a default value. What this means: 
#   If the Value matches Default, delete Label from Record.
#   Otherwise, set Label to Value in Record.
prog putd [[[rot3] dip eq del] [drop put] try-else]
assert [
    6 7 0 'x put 'y put copy 
    42 swap 'x 42 putd 
    ['y get 6 eq] verify
    ['x get] verify-not
    drop
    42 swap 'x 0 putd
    ['y get 6 eq] verify
    'x get 42 eq
]

# Constructing records directly from stack items.
# 
# In these cases, we usually have static labels in the local program,
# and values provided later at runtime.
# 
# d0            -- ()
# d1            V1 L1 -- L1:V1
# d2            V1 V2 L1 L2 -- (L1:V1, L2:V2)
# d3            V1 V2 V3 L1 L2 L3 -- (L1:V1, L2:V2, L3:V3)
# d4..d7        similarly

data d0 [0]
prog d1 [d0 swap put]
prog d2 [[rot2 [d1] dip swap] dip put]
prog d3 [[rot3 [d2] dip swap] dip put]
prog d4 [[rot4 [d3] dip swap] dip put]
prog d5 [[rot5 [d4] dip swap] dip put]
prog d6 [[rot6 [d5] dip swap] dip put]
prog d7 [[rot7 [d6] dip swap] dip put]

assert [
    1 2 3 4 5 6 7 
    ['x 'y 'z 'a 'b 'c 'd d7] apply
    copy
    'a get 4 eq
    'x get 1 eq
]

# Pseudo-literal construction of records.
# 
#   d0 'x 6
#   di 'y 7
#   di ... ops on dict
#
# d0          -- ()
# di          (Record Label Value -- Record)    'dict item'
prog di [unrot3 put]

assert [
    d0 'x 11
    di 'y 12
    di 'z 13
    di 'point d1
    copy
    'point get 'y get 12 eq
    'point get 'x get 11 eq
]

# Variants aka Tagged Unions
#
# We'll represent variants as a singleton record `label:Value`.
# Access to the value is 
#

# ANNOTATIONS SUPPORT

# p-prog-body       Program -- Program
#  returns main behavior of a program, i.e. stripping the
#  `prog:do:` annotations header, if any (recursively)
prog p-prog-body [['prog get 'do p-nop getd] loop]

# p-prog-anno       Program -- Annotations
#  returns header annotations for programs that have some.
#  returns empty record if no header annotations. 
prog p-prog-anno [['prog get 'do del] [drop 0] try-else]

# p-prog-anno-set   Program Annotations -- Program
#  set header annotations for a program. Or clear annotations
#  if an empty record of annotations is set.
prog p-prog-anno-set [
    [p-prog-body] dip
    ['do del 0 eq]['do put 0 'prog put] try-else
]

# p-prog-anno-put       ([Program] Value Label -- [Program](Label:Value))
#  add a specific annotation to a program.
prog p-prog-anno-put [[[copy p-prog-anno] dip swap] dip put p-prog-anno-set]

# p-prog-anno-get       ([Program](Label:Value) Label -- Value)
prog p-prog-anno-get [[p-prog-anno] dip get]

# p-prog-anno-getd      ([Program](Label?_) Label Value -- Value)
#  get annotated value with a default.
prog p-prog-anno-getd [[p-prog-anno] dip2 getd]

# p-anno-accel      ([Program] Model -- [Program](accel:Model))
#
#  Example usage: 
#       prog list-append [[list-append-impl] 'list-append p-anno-accel]
#
#  Acceleration is an essential performance annotation for Glas systems.
#  It informs a compiler to substitute a subprogram with a highly optimized
#  implementation that can take advantage of underlying representations and
#  other hidden details. This supports extension with performance features.
#
prog p-anno-accel ['accel p-prog-anno-put]
prog p-anno-accel-get ['accel p-prog-anno-get]

# p-anno-arity      ([Program] In Out -- [Program](arity:(i:In, o:Out)))
#
#  Arity annotations will often be checked for consistency, but might not
#  be exact due to using less data than the arity would suggest.
#
prog p-anno-arity ['i 'o d2 'arity p-prog-anno-put]
prog p-anno-arity-get ['arity p-prog-anno-get copy 'i get swap 'o get]

assert [
    42 p-nop p-curry 
    14 15 p-anno-arity 
    'xyzzy p-anno-accel
    copy 
    p-anno-arity-get pair 14 15 pair eq
    p-anno-accel-get 'xyzzy eq
]

# Future annotations/prims should support:
#  memoization, stowage
#  type safety analysis
#  preconditions and postconditions

# BASIC LOGGING
#
# Logging is convenient for debugging or tracking progress of an application.
# Most effects APIs will include a 'log:Message' or equivalent. This includes
# compile-time evaluation.
#
# The message should be a record such as (lv:warn, text:"there is an issue").
# This allows for some extra context to be added to the message, and extension
# with structured message types. However, messages are ultimately intended for
# humans.
#
# An effects handler may disable log messages for a subprogram. Failure will
# be silently ignored. 
#

# log-send      Message --
#  Sends provided Message as a logging effect, dropping unit result. 
#  Failure is silently ignored.
prog log-send [[0 'log put eff 0 eq][drop] try-else]

# log message builders
#   logmsg-text-lv         "Hello" 'warn -- (lv:warn, text:"Hello")
#   logmsg-val-text-lv   42 "Hello" 'warn -- (lv:warn, text:"Hello", val:42)
# Will drop an empty/unit text, level, or value field.
prog logmsg-text-lv [0 'lv 0 putd 'text 0 putd]
prog logmsg-val-text-lv [logmsg-text-lv 'val 0 putd]

# "Message" log-info  (or log-warn or log-error)
prog log-info ['info logmsg-text-lv log-send]
prog log-warn ['warn logmsg-text-lv log-send]
prog log-error ['error logmsg-text-lv log-send]

# Value "Message" log-info-v  (or log-warn-v or log-error-v)
prog log-info-v ['info logmsg-val-text-lv log-send]
prog log-warn-v ['warn logmsg-val-text-lv log-send]
prog log-error-v ['error logmsg-val-text-lv log-send]

# LOADING MODULES OR DEFINITIONS
#
# The 'load' effect is supported by language modules and glas CLI apps.
# The essential idea is to obtain a value from the module system. The
# basic targets are 'global:"ModuleName"' or 'local:"ModuleName". The
# g0 compiler extends this to further support 'dict' and 'dict:word'.
#

# ModuleRef load-ref (any valid ref)
prog load-ref  [ 'load d1 eff ]

# load-dict (compile-time effect for g0)
# Load current dictionary as data. 
# Excludes words defined later within file.
prog load-dict [ 'dict load-ref ]

# 'word load-word (compile-time effect for g0)
# This will load a definition as data. 
prog load-word [ 'dict d1 load-ref ]

# "ModuleName" load-global (load a local module)
prog load-global [ 'global d1 load-ref ]

# "ModuleName" load-local (load a global module)
prog load-local [ 'local d1 load-ref ]
