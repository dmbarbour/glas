# The 'prims' module provides a useful set of words for getting started with
# the g0 language. Not all are true primitives, just stuff that is relatively
# concrete, widely useful, low level, and doesn't require too much logic.
#
# At the moment, list ops, natural number arithmetic, and advanced record ops
# such as iteration over keys is left to external modules.

macro apply []

# TRUE PRIMITIVES

prog copy ['copy apply]
prog swap ['swap apply]
prog drop ['drop apply]

prog eq ['eq apply]
prog eff ['eff apply]
prog fail ['fail apply]

prog get ['get apply]
prog put ['put apply]
prog del ['del apply]

prog p-dip [0 'dip put]
prog p-while-do [0 'do put 'while put 0 'loop put]
prog p-until-do [0 'do put 'until put 0 'loop put]
prog p-try-then-else [0 'else put 'then put 'try put 0 'cond put]
prog p-with-do [0 'do put 'with put 0 'env put]

macro dip [p-dip]
macro while-do [p-while-do]
macro until-do [p-until-do]
macro try-then-else [p-try-then-else]
macro with-do [p-with-do]

# PAIRS - trees with both the '0' and '1' edges.
# Pairs are mostly used for construction of lists.

prog pair [0 0b1 put 0b0 put]
prog pair-fst [0b0 get]
prog pair-snd [0b1 get]
prog unpair [copy pair-fst swap pair-snd]
assert [1 2 3 pair pair pair-snd unpair 3 eq 2 eq]

# DATA AND SEQ MACRO SUPPORT
#
# No need for 'data' or 'seq' as macros, but p-* forms
# are very convenient for construction of new macros.

# p-data    Value -- [Value]
prog p-data [0 'data put]

# p-seq     ([A] [B] -- [A B])
#  compose two programs sequentially.
prog p-seq  [['seq get] [pair] [0 pair pair] try-then-else 0 'seq put]

# p-curry   (Value [Fn] -- [Value Fn])
#  bind first parameter into a program value.
prog p-curry [[p-data] dip p-seq]

# p-nop     -- []
#  non-operation in Glas is empty seq
#  (explicit to prevent annotations from g0 compiler)
data p-nop ['seq]

assert [1 [2 pair] p-curry apply unpair 2 eq 1 eq]

# CONDITIONAL VARIATIONS

# try       ([P]try == [P][][]try-then-else)
# try-then  ([P][L]try-then == [P][L][]try-then-else)
# try-else  ([P][R]try-else == [P][][R]try-then-else)
prog p-try [0 'try put 0 'cond put]
prog p-try-then [0 'then put 'try put 0 'cond put]
prog p-try-else [0 'else put 'try put 0 'cond put]
macro try [p-try]
macro try-then [p-try-then]
macro try-else [p-try-else]

# NON-MODIFYING OBSERVATIONS
#
# Many uses of these operations might be better expressed as typechecks.

# verify    ([Predicate] -- | FAIL)
#  evaluates predicate, then undoes effects.
#  passes if the predicate would pass, fails otherwise.
prog p-verify [[fail] p-try-then [fail] p-try-then]
macro verify [p-verify]
assert [0 [0 eq] verify 0 eq]
assert [0 [[1 eq] verify][1][2] try-then-else 2 eq 0 eq]

# verify-not ([Predicate] -- | FAIL)
#  evaluates predicate, then undoes effects.
#  passes if predicate would fail, succeeds otherwise.
prog p-verify-not [[fail] p-try-then [fail] p-try-else]
macro verify-not [p-verify-not]
assert [0 [1 eq] verify-not 0 eq]
assert [0 [[0 eq] verify-not][1][2] try-then-else 2 eq 0 eq]

# LOOP VARIATIONS

# loop          ([Op]loop)
#  run sub-program repeatedly until it fails.
prog p-loop [0 'while put 0 'loop put]
macro loop [p-loop]

# do-while      ([Body][Cond]do-while)
#  run Body before checking condition. Equivalent: 
#    Body [Cond] [Body] while-do
prog p-do-while [[copy] dip swap p-while-do p-seq]
macro do-while [p-do-while]

# do-until      ([Body][Cond]do-until)
#  run Body before checking condition. Equivalent:
#    Body [Cond] [Body] until-do
prog p-do-until [[copy] dip swap p-until-do p-seq]
macro do-until [p-do-until]

# DATA PLUMBING SUPPORT
# 
# rot3      (X Y Z -- Y Z X)        rotate 3rd item to top
# unrot3    (X Y Z -- Z X Y)               top item to 3rd
# copy2     (X Y -- X Y X Y)        copy two items on stack
# drop2     (X Y -- )               drop two items from stack
# dip2      (X Y [Op] -- Op X Y)    hide two items from Op
#
# All of these have variants from 2..7. However, a data stack over a few
# elements grows difficult to mentally track or manage, so you should be
# organizing data (into records, lists, etc.) to keep the stack small.

prog rot2 [swap]
prog rot3 [[rot2] dip swap]
prog rot4 [[rot3] dip swap]
prog rot5 [[rot4] dip swap]
prog rot6 [[rot5] dip swap]
prog rot7 [[rot6] dip swap]

assert [1 2 3 4 5 6 7 rot7 1 eq 7 eq 6 eq 5 eq 4 eq 3 eq 2 eq]

prog unrot2 [swap]
prog unrot3 [swap [unrot2] dip]
prog unrot4 [swap [unrot3] dip]
prog unrot5 [swap [unrot4] dip]
prog unrot6 [swap [unrot5] dip]
prog unrot7 [swap [unrot6] dip]

assert [1 2 3 4 5 6 7 unrot7 6 eq 5 eq 4 eq 3 eq 2 eq 1 eq 7 eq]

prog copy2 [[copy ] dip copy [unrot2] dip]
prog copy3 [[copy2] dip copy [unrot3] dip]
prog copy4 [[copy3] dip copy [unrot4] dip]
prog copy5 [[copy4] dip copy [unrot5] dip]
prog copy6 [[copy5] dip copy [unrot6] dip]
prog copy7 [[copy6] dip copy [unrot7] dip]

assert [1 2 3 4 5 6 7 copy7 [7 eq 6 eq 5 eq 4 eq 3 eq 2 eq] copy dip dip 1 eq 1 eq]

prog drop2 [drop drop]
prog drop3 [drop drop drop]
prog drop4 [drop drop drop drop]
prog drop5 [drop drop drop drop drop]
prog drop6 [drop drop drop drop drop drop]
prog drop7 [drop drop drop drop drop drop drop]

assert [1 2 3 4 5 6 7 8 drop7 1 eq]

macro dip2 [p-dip p-dip]
macro dip3 [p-dip p-dip p-dip]
macro dip4 [p-dip p-dip p-dip p-dip]
macro dip5 [p-dip p-dip p-dip p-dip p-dip]
macro dip6 [p-dip p-dip p-dip p-dip p-dip p-dip]
macro dip7 [p-dip p-dip p-dip p-dip p-dip p-dip p-dip]

assert [1 2 3 4 5 6 7 8 9 [2 eq] dip7 9 eq 8 eq 7 eq 6 eq 5 eq 4 eq 3 eq 1 eq]

# CONVENIENCE FUNCTIONS FOR RECORDS AND VARIANTS

# getd          Record Label Default -- Value
#  get with a default value.
prog getd [[drop get] [[drop2] dip] try-else]

assert [42 0 'x put copy 'x 0 getd 42 eq 'y 0 getd 0 eq]

# putd          Value Record Label Default -- Record
#  put with a default value. What this means: 
#   If the Value matches Default, delete Label from Record.
#   Otherwise, set Label to Value in Record.
prog putd [[[rot3] dip eq del] [drop put] try-else]
assert [
    6 7 0 'x put 'y put copy 
    42 swap 'x 42 putd 
    ['y get 6 eq] verify
    ['x get] verify-not
    drop
    42 swap 'x 0 putd
    ['y get 6 eq] verify
    'x get 42 eq
]

# Constructing records directly from stack items.
# 
# In these cases, we usually have static labels in the local program,
# and values provided later at runtime.
# 
# d0            -- ()
# d1            V1 L1 -- L1:V1
# d2            V1 V2 L1 L2 -- (L1:V1, L2:V2)
# d3            V1 V2 V3 L1 L2 L3 -- (L1:V1, L2:V2, L3:V3)
# d4..d7        similarly

data d0 [0]
prog d1 [d0 swap put]
prog d2 [[rot2 [d1] dip swap] dip put]
prog d3 [[rot3 [d2] dip swap] dip put]
prog d4 [[rot4 [d3] dip swap] dip put]
prog d5 [[rot5 [d4] dip swap] dip put]
prog d6 [[rot6 [d5] dip swap] dip put]
prog d7 [[rot7 [d6] dip swap] dip put]

assert [
    1 2 3 4 5 6 7 
    ['x 'y 'z 'a 'b 'c 'd d7] apply
    copy
    'a get 4 eq
    'x get 1 eq
]

# Pseudo-literal construction of records.
# 
#   d0 'x 6
#   di 'y 7
#   di ... ops on dict
#
# d0          -- ()
# di          (Record Label Value -- Record)    'dict item'
prog di [unrot3 put]

assert [
    d0 'x 11
    di 'y 12
    di 'z 13
    di 'point d1
    copy
    'point get 'y get 12 eq
    'point get 'x get 11 eq
]

# ANNOTATIONS SUPPORT

# p-prog-body       Program -- Program
#  returns main behavior of a program, i.e. stripping the
#  `prog:do:` annotations header, if any (recursively)
prog p-prog-body [['prog get 'do p-nop getd] loop]

# p-prog-anno       Program -- Annotations
#  returns header annotations for programs that have some.
#  returns empty record if no header annotations. 
prog p-prog-anno [['prog get 'do del] [drop 0] try-else]

# p-prog-anno-set   Program Annotations -- Program
#  set header annotations for a program. Or clear annotations
#  if an empty record of annotations is set.
prog p-prog-anno-set [
    [p-prog-body] dip
    ['do del 0 eq]['do put 0 'prog put] try-else
]

# p-prog-anno-put       ([Program] Value Label -- [Program](Label:Value))
#  add a specific annotation to a program.
prog p-prog-anno-put [[[copy p-prog-anno] dip swap] dip put p-prog-anno-set]

# p-prog-anno-get       ([Program](Label:Value) Label -- Value)
prog p-prog-anno-get [[p-prog-anno] dip get]

# p-prog-anno-getd      ([Program](Label?_) Label Value -- Value)
#  get annotated value with a default.
prog p-prog-anno-getd [[p-prog-anno] dip2 getd]

# p-anno-accel      ([Program] Model -- [Program](accel:Model))
#
#  Acceleration is the most performance-critical annotation. It asks the
#  compiler or interpreter to substitute an optimized implementation or 
#  to raise warnings or errors. The 'Model' is really a compiler hint,
#  usually just a symbol.
#  
prog p-anno-accel ['accel p-prog-anno-put]
prog p-anno-accel-get ['accel p-prog-anno-get]

# p-anno-arity      ([Program] In Out -- [Program](arity:(i:In, o:Out)))
#
#  Arity annotations will often be checked for consistency, but might not
#  be exact due to using less data than the arity would suggest.
#
prog p-anno-arity ['i 'o d2 'arity p-prog-anno-put]
prog p-anno-arity-get ['arity p-prog-anno-get copy 'i get swap 'o get]

assert [
    42 p-nop p-curry 
    14 15 p-anno-arity 
    'xyzzy p-anno-accel
    copy 
    p-anno-arity-get pair 14 15 pair eq
    p-anno-accel-get 'xyzzy eq
]

# Future annotations should support:
#  memoization, stowage
#  type safety analysis
#  preconditions and postconditions
#  labeled inputs and outputs to simplify auto-wiring

# BASIC LOGGING
#
# Logging is convenient for debugging or tracking progress of an application.
# Most application models in Glas systems will support an effect 'log:Message'
# that should respond with unit value (0). If not, we can ignore log failures.
# 
# By convention, Message is a record such as `(lv:warn, text:"problem found")`.
# This may be extended with new fields on an ad-hoc basis, e.g. we could have
# log messages specifically to support progress bars or notifications.
#
# Compile-time also produces a log. Thus, g0 can perform compile-time logging
# via macro calls, data definitions, assertions, or the export function. This
# is convenient when debugging why an assertion has failed, or warning about a
# deprecated accelerator that will soon be eliminated.
#

# log-send      Message --
#  Sends provided Message as a logging effect. Failure is silently ignored.
prog log-send [[0 'log put eff 0 eq][drop] try-else]

# log message builders
#   log-msg-text-lv         "Hello" 'warn -- (lv:warn, text:"Hello")
#   log-msg-val-text-lv   42 "Hello" 'warn -- (lv:warn, text:"Hello", val:42)
# Will drop a 0 text, level, or value field.
prog log-msg-text-lv [0 'lv 0 putd 'text 0 putd]
prog log-msg-val-text-lv [log-msg-text-lv 'val 0 putd]

# "Message" log-info  (or log-warn or log-error)
prog log-info ['info log-msg-text-lv log-send]
prog log-warn ['warn log-msg-text-lv log-send]
prog log-error ['error log-msg-text-lv log-send]

# Value "Message" log-info-v  (or log-warn-v or log-error-v)
prog log-info-v ['info log-msg-val-text-lv log-send]
prog log-warn-v ['warn log-msg-val-text-lv log-send]
prog log-error-v ['error log-msg-val-text-lv log-send]
