open prims
import bits as b
import bits-basics as bb
from [bb] import
    int-increment as increment,
    int-decrement as decrement,
    bits-negate as negate,
    p-repeat, repeat,
    type-int, type-nat
import nat as n

prog is-pos [type-int [0b1 get] verify]
prog is-neg [type-int [0b0 get] verify]
prog is-nat [type-int [0b0 get] reject]
prog is-zero [0 eq1]


# subtract nat from nat, resulting in integer
prog sub-nn [
    [n/sub]                 # fails for negative result
    [swap n/sub negate]     # (A-B) = -(B-A)
    try-else
]

prog add-impl [
    [[is-neg negate] dip]
    [[is-neg negate]
     [n/add negate]  # neg + neg
     [swap sub-nn]   # neg + pos
     try-then-else
    ]
    [[is-neg negate]
     [sub-nn]        # pos + neg
     [n/add]         # pos + pos
     try-then-else
    ]
    try-then-else
]

# add two integers
prog add [add-impl]

assert [-9 19 add 10 eq]
assert [-9 -19 add -28 eq]
assert [9 -19 add -10 eq]

prog sub-impl [negate add]

# subtract two integers
prog sub [sub-impl]

assert [19 9 sub 10 eq]
assert [9 19 sub -10 eq]
assert [19 -9 sub 28 eq]
assert [-9 19 sub -28 eq]
assert [-19 9 sub -28 eq]
assert [-9 -19 sub 10 eq]

prog mul [
    [[is-neg negate] dip]
    [   
        [is-neg negate]
        [n/mul]         # neg * neg
        [n/mul negate]  # neg * pos
        try-then-else
    ]
    [
        [is-neg negate]
        [n/mul negate]  # pos * neg
        [n/mul]         # pos * pos
        try-then-else
    ]
    try-then-else
]
assert [-3 4 mul -12 eq]
assert [-7 -4 mul 28 eq]
assert [9 -7 mul -63 eq]
assert [7 6 mul 42 eq]

# Dividend Divisor -- Quotient Remainder
#   Quotient * Divisor + Remainder = Dividend
#   Remainder between 0 (incl) and Divisor (excl).
#   (That is, non-zero Remainder has sign of Divisor.)
#
#   For example:
#
#      -17 -5 =>  3 -2
#      -17  5 => -4  3
#       17 -5 => -4 -3
#       17  5 =>  3  2
#
prog divmod [
    #  I currently don't have a good idea how to simplify this.
    #  Simply handling each sign case.
    [[is-neg negate] dip]
    [
        [is-neg negate]
        [n/divmod negate] # -17 -5 =>  3 -2
        [copy [n/divmod [negate decrement] dip] dip swap n/sub]  # -17  5 => -4  3
        try-then-else
    ]
    [
        [is-neg negate]
        [copy [n/divmod [negate decrement] dip] dip swap n/sub negate] # 17 -5 => -4 -3
        [n/divmod]
        try-then-else
    ]
    try-then-else
]

# need a bit more confidence in divmod...

prog test-divmod [pair [divmod pair] dip eq]
assert [ 17  5  3  2 test-divmod]
assert [ 17 -5 -4 -3 test-divmod]
assert [-17  5 -4  3 test-divmod]
assert [-17 -5  3 -2 test-divmod]

assert [-4 3 -2 2 test-divmod]
assert [-3 3 -1 0 test-divmod]
assert [-2 3 -1 1 test-divmod]
assert [-1 3 -1 2 test-divmod]
assert [ 0 3  0 0 test-divmod]
assert [ 1 3  0 1 test-divmod]
assert [ 2 3  0 2 test-divmod]
assert [ 3 3  1 0 test-divmod]
assert [ 4 3  1 1 test-divmod]

assert [-4 -3  1 -1 test-divmod]
assert [-3 -3  1  0 test-divmod]
assert [-2 -3  0 -2 test-divmod]
assert [-1 -3  0 -1 test-divmod]
assert [ 0 -3  0  0 test-divmod]
assert [ 1 -3 -1 -2 test-divmod]
assert [ 2 -3 -1 -1 test-divmod]
assert [ 3 -3 -1  0 test-divmod]
assert [ 4 -3 -2 -2 test-divmod]



prog div [ divmod drop ]
prog mod [ divmod swap drop ]

export 
    add, sub, mul, 
    divmod, div, mod,
    increment, decrement, negate,
    repeat, p-repeat, 
    type-int, type-nat,
    is-pos, is-neg, is-nat, is-zero
